"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sortMethod = require("./sort-method");

var _sortMethod2 = _interopRequireDefault(_sortMethod);

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

var _lodash = require("lodash");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GrowingPacker = function () {
	function GrowingPacker() {
		var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		var _ref$sortMethod = _ref.sortMethod;
		var sortMethod = _ref$sortMethod === undefined ? _sortMethod2.default.maxside : _ref$sortMethod;
		var _ref$blocks = _ref.blocks;
		var blocks = _ref$blocks === undefined ? [] : _ref$blocks;

		_classCallCheck(this, GrowingPacker);

		this.sortMethod = (0, _lodash.isFunction)(sortMethod) ? sortMethod : _sortMethod2.default[sortMethod];
		this.blocks = blocks;

		(0, _assert2.default)((0, _lodash.isArray)(blocks), 'blocks parameters must be an Array');
		(0, _assert2.default)((0, _lodash.isFunction)(this.sortMethod), 'sortMethod parameters must be a function or a valid sort method name');

		this.root = {
			x: 0,
			y: 0,
			w: 0,
			h: 0
		};
	}

	/*inject(){
 	return this;
 }
 
 init(){
 	return this;
 }*/

	_createClass(GrowingPacker, [{
		key: "pack",
		value: function pack() {
			var _this = this;

			var blocks = arguments.length <= 0 || arguments[0] === undefined ? this.blocks : arguments[0];

			blocks.sort(this.sortMethod);

			var n = void 0,
			    node = void 0,
			    block = void 0,
			    len = blocks.length;
			var w = len > 0 ? blocks[0].w : 0;
			var h = len > 0 ? blocks[0].h : 0;

			this.root = {
				x: 0,
				y: 0,
				w: w,
				h: h
			};

			for (n = 0; n < len; n++) {
				block = blocks[n];
				if (node = this.findNode(this.root, block.w, block.h)) {
					block.fit = this.splitNode(node, block.w, block.h);
				} else {
					block.fit = this.growNode(block.w, block.h);
				}
			}

			return {
				blocks: blocks,
				rectangles: function rectangles() {
					return _this.rectangles(blocks);
				},
				width: this.width,
				height: this.height
			};
		}
	}, {
		key: "rectangles",
		value: function rectangles() {
			var blocks = arguments.length <= 0 || arguments[0] === undefined ? this.blocks : arguments[0];

			(0, _lodash.forEach)(blocks, function (block) {
				var fit = block.fit;

				block.fit = (0, _lodash.isObject)(fit);
				block.x = fit.x;
				block.y = fit.y;
				block.width = block.w;
				block.height = block.h;
			});

			return blocks;
		}
	}, {
		key: "findNode",
		value: function findNode(root, w, h) {
			if (root.used) {
				return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);
			} else if (w <= root.w && h <= root.h) {
				return root;
			}

			return null;
		}
	}, {
		key: "splitNode",
		value: function splitNode(node, w, h) {
			node.used = true;
			node.down = {
				x: node.x,
				y: node.y + h,
				w: node.w,
				h: node.h - h
			};

			node.right = {
				x: node.x + w,
				y: node.y,
				w: node.w - w,
				h: h
			};

			return node;
		}
	}, {
		key: "growNode",
		value: function growNode(w, h) {
			var canGrowDown = w <= this.root.w;
			var canGrowRight = h <= this.root.h;

			var shouldGrowRight = canGrowRight && this.root.h >= this.root.w + w; // attempt to keep square-ish by growing right when height is much greater than width
			var shouldGrowDown = canGrowDown && this.root.w >= this.root.h + h; // attempt to keep square-ish by growing down  when width  is much greater than height

			if (shouldGrowRight) {
				return this.growRight(w, h);
			} else if (shouldGrowDown) {
				return this.growDown(w, h);
			} else if (canGrowRight) {
				return this.growRight(w, h);
			} else if (canGrowDown) {
				return this.growDown(w, h);
			}

			return null; // need to ensure sensible root starting size to avoid this happening
		}
	}, {
		key: "growRight",
		value: function growRight(w, h) {
			var node = void 0;

			this.root = {
				used: true,
				x: 0,
				y: 0,
				w: this.root.w + w,
				h: this.root.h,
				down: this.root,
				right: {
					x: this.root.w,
					y: 0,
					w: w,
					h: this.root.h
				}
			};

			if (node = this.findNode(this.root, w, h)) {
				return this.splitNode(node, w, h);
			}

			return null;
		}
	}, {
		key: "growDown",
		value: function growDown(w, h) {
			var node = void 0;

			this.root = {
				used: true,
				x: 0,
				y: 0,
				w: this.root.w,
				h: this.root.h + h,
				down: {
					x: 0,
					y: this.root.h,
					w: this.root.w,
					h: h
				},
				right: this.root
			};

			if (node = this.findNode(this.root, w, h)) {
				return this.splitNode(node, w, h);
			}

			return null;
		}
	}, {
		key: "size",
		get: function get() {
			return {
				width: this.width,
				height: this.height
			};
		}
	}, {
		key: "width",
		get: function get() {
			return this.root.w;
		}
	}, {
		key: "height",
		get: function get() {
			return this.root.h;
		}
	}]);

	return GrowingPacker;
}();

exports.default = GrowingPacker;
//# sourceMappingURL=index.js.map
